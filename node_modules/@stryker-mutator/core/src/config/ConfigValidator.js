"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const di_1 = require("../di");
class ConfigValidator {
    constructor(log, options, testFramework) {
        this.log = log;
        this.options = options;
        this.testFramework = testFramework;
        this.isValid = true;
    }
    validate() {
        this.validateTestFramework();
        this.validateThresholds();
        this.validateMutator();
        this.validateLogLevel('logLevel');
        this.validateLogLevel('fileLogLevel');
        this.validateTimeout();
        this.validateIsNumber('maxConcurrentTestRunners', this.options.maxConcurrentTestRunners);
        this.validateIsStringArray('plugins', this.options.plugins);
        this.validateIsStringArray('reporters', this.options.reporters);
        this.validateIsStringArray('transpilers', this.options.transpilers);
        this.validateIsString('tempDirName', this.options.tempDirName);
        this.validateCoverageAnalysis();
        this.validateCoverageAnalysisWithRespectToTranspilers();
        this.crashIfNeeded();
    }
    validateTestFramework() {
        if (this.options.coverageAnalysis === 'perTest' && !this.testFramework) {
            this.invalidate('Configured coverage analysis "perTest" requires there to be a testFramework configured. Either configure a testFramework or set coverageAnalysis to "all" or "off".');
        }
    }
    validateMutator() {
        const mutator = this.options.mutator;
        if (typeof mutator === 'object') {
            const mutatorDescriptor = mutator;
            this.validateIsString('mutator.name', mutatorDescriptor.name);
            this.validateIsStringArray('mutator.excludedMutations', mutatorDescriptor.excludedMutations);
        }
        else if (typeof mutator !== 'string') {
            this.invalidate(`Value "${mutator}" is invalid for \`mutator\`. Expected either a string or an object`);
        }
    }
    validateThresholds() {
        const thresholds = this.options.thresholds;
        this.validateThresholdsValueExists('high', thresholds.high);
        this.validateThresholdsValueExists('low', thresholds.low);
        this.validateThresholdValue('high', thresholds.high);
        this.validateThresholdValue('low', thresholds.low);
        this.validateThresholdValue('break', thresholds.break);
        if (thresholds.high < thresholds.low) {
            this.invalidate(`\`thresholds.high\` is lower than \`thresholds.low\` (${thresholds.high} < ${thresholds.low})`);
        }
    }
    validateThresholdValue(name, value) {
        if (typeof value === 'number' && (value < 0 || value > 100)) {
            this.invalidate(`Value "${value}" is invalid for \`thresholds.${name}\`. Expected a number between 0 and 100`);
        }
    }
    validateThresholdsValueExists(name, value) {
        if (typeof value !== 'number') {
            this.invalidate(`Value "${value}" is invalid for \`thresholds.${name}\`. Expected a number between 0 and 100`);
        }
    }
    validateLogLevel(logProperty) {
        const logLevel = this.options[logProperty];
        const VALID_LOG_LEVEL_VALUES = [core_1.LogLevel.Fatal, core_1.LogLevel.Error, core_1.LogLevel.Warning, core_1.LogLevel.Information, core_1.LogLevel.Debug, core_1.LogLevel.Trace, core_1.LogLevel.Off];
        if (VALID_LOG_LEVEL_VALUES.indexOf(logLevel) < 0) {
            this.invalidate(`Value "${logLevel}" is invalid for \`logLevel\`. Expected one of the following: ${this.joinQuotedList(VALID_LOG_LEVEL_VALUES)}`);
        }
    }
    validateTimeout() {
        this.validateIsNumber('timeoutMS', this.options.timeoutMS);
        this.validateIsNumber('timeoutFactor', this.options.timeoutFactor);
    }
    validateCoverageAnalysis() {
        const VALID_COVERAGE_ANALYSIS_VALUES = ['perTest', 'all', 'off'];
        const coverageAnalysis = this.options.coverageAnalysis;
        if (VALID_COVERAGE_ANALYSIS_VALUES.indexOf(coverageAnalysis) < 0) {
            this.invalidate(`Value "${coverageAnalysis}" is invalid for \`coverageAnalysis\`. Expected one of the following: ${this.joinQuotedList(VALID_COVERAGE_ANALYSIS_VALUES)}`);
        }
    }
    validateCoverageAnalysisWithRespectToTranspilers() {
        if (Array.isArray(this.options.transpilers) &&
            this.options.transpilers.length > 1 &&
            this.options.coverageAnalysis !== 'off') {
            this.invalidate(`Value "${this.options.coverageAnalysis}" for \`coverageAnalysis\` is invalid with multiple transpilers (configured transpilers: ${this.options.transpilers.join(', ')}). Please report this to the Stryker team if you whish this feature to be implemented`);
        }
    }
    crashIfNeeded() {
        if (!this.isValid) {
            throw new util_1.StrykerError('Stryker could not recover from this configuration error, see fatal log message(s) above.');
        }
    }
    validateIsNumber(fieldName, value) {
        if (typeof value !== 'number' || isNaN(value)) {
            this.invalidate(`Value "${value}" is invalid for \`${fieldName}\`. Expected a number`);
        }
    }
    validateIsString(fieldName, value) {
        if (typeof value !== 'string') {
            this.invalidate(`Value "${value}" is invalid for \`${fieldName}\`. Expected a string`);
        }
    }
    validateIsStringArray(fieldName, value) {
        if (!Array.isArray(value)) {
            this.invalidate(`Value "${value}" is invalid for \`${fieldName}\`. Expected an array`);
        }
        else {
            value.forEach(v => {
                if (typeof v !== 'string') {
                    this.invalidate(`Value "${v}" is an invalid element of \`${fieldName}\`. Expected a string`);
                }
            });
        }
    }
    invalidate(message) {
        this.log.fatal(message);
        this.isValid = false;
    }
    joinQuotedList(arr) {
        return arr.map(v => `"${v}"`).join(', ');
    }
}
ConfigValidator.inject = plugin_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options, di_1.coreTokens.testFramework);
exports.default = ConfigValidator;
//# sourceMappingURL=ConfigValidator.js.map